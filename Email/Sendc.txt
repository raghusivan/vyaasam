I understand now that you're using an internal SMTP server to send emails to external addresses like Hotmail or Gmail, and you want to receive a response from the recipient's mail server (e.g., Hotmail or Gmail) to confirm that the email has been accepted or delivered by their servers.

Limitations of Standard SMTP

Unfortunately, SMTP by itself is a store-and-forward protocol, which means that your internal SMTP server does not usually get a direct response from external servers (like Hotmail or Gmail) beyond a confirmation that it has passed the email to the next hop. Once your SMTP server forwards the email, it doesn't have visibility into what happens after that. SMTP typically doesn't give feedback from the recipient's mail server (like Hotmail) unless you use a special mechanism such as Delivery Status Notifications (DSN) or Return Receipts.

Options to Get Responses from Recipient Servers

1. Delivery Status Notification (DSN): This is the most reliable way to ask for a delivery report or failure report from the recipient's email server.

You can request a DSN when you send the email. If the recipient's mail server supports DSNs, it will send a report back to your internal SMTP server, which you can capture.

The recipient's mail server (e.g., Hotmail or Gmail) may respond with a delivery confirmation or failure notification.



2. Return Receipt (Read Receipt): This requests a notification when the recipient opens the email. However, this depends on the recipient's email client and settings, and the user may choose not to send a read receipt.


3. SMTP Logs: You can check your internal SMTP server logs to see if there are any error messages or bounces from the recipient's mail servers.



Modifying the Script to Request a DSN

Here's how you can modify the Python script to request a Delivery Status Notification (DSN) from the recipient's server (Hotmail, Gmail, etc.).

import os
import smtplib
import socket
import ConfigParser
from email import message_from_file
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# Read configuration from config.ini
config = ConfigParser.ConfigParser()
config.read('config.ini')

# SMTP Configuration
smtp_server = config.get('SMTP', 'smtp_server')
smtp_port = config.getint('SMTP', 'smtp_port')
smtp_user = config.get('SMTP', 'smtp_user')
smtp_password = config.get('SMTP', 'smtp_password')

# Email Configuration
extensions = [ext.strip() for ext in config.get('Email', 'extensions').split(',')]

# Function to send .eml files as attachments, using subject from the .eml and requesting DSN (Delivery Status Notification)
def send_eml_files():
    try:
        # Create an SMTP connection
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.set_debuglevel(1)  # Enable detailed debugging output to see all communication with the SMTP server
        server.ehlo()
        server.starttls()  # Secure the connection
        server.ehlo()

        # Login
        server.login(smtp_user, smtp_password)

        # Process each .eml file
        for filename in os.listdir('.'):  # Iterate through files in the current directory
            if os.path.isfile(filename) and any(filename.endswith(ext) for ext in extensions):  # Filter based on extension
                print("Processing file: {}".format(filename))
                with open(filename, 'r') as eml_file:
                    msg = message_from_file(eml_file)  # Read the .eml file as an email message

                    # Get the subject from the .eml file
                    subject = str(msg['Subject'])

                    # Create a multipart message
                    email_msg = MIMEMultipart()
                    email_msg['From'] = smtp_user
                    email_msg['To'] = config.get('Email', 'to_address')  # Assuming the recipient is set in config
                    email_msg['Subject'] = subject  # Use subject from .eml

                    # Add headers for DSN (Delivery Status Notification)
                    email_msg.add_header('Disposition-Notification-To', smtp_user)  # Request read receipt
                    email_msg.add_header('Return-Receipt-To', smtp_user)  # Request delivery status notification

                    # Attach a simple text body (optional)
                    body = "Please see the attached journal file."
                    email_msg.attach(MIMEText(body, 'plain'))

                    # Attach the .eml file
                    with open(filename, 'rb') as attachment_file:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(attachment_file.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', 'attachment; filename="{}"'.format(filename))
                        email_msg.attach(part)

                    # Request Delivery Status Notification (DSN)
                    try:
                        response = server.sendmail(email_msg['From'], email_msg['To'], email_msg.as_string(),
                                                   dsn_options=['SUCCESS', 'FAILURE', 'DELAY'])

                        # Print the response from the SMTP server
                        if response == {}:
                            print("Email successfully sent and accepted for delivery: {}".format(filename))
                        else:
                            print("Email sent with response: {}, filename: {}".format(response, filename))

                    except smtplib.SMTPResponseException as smtp_error:
                        # Catch specific SMTP errors and print the error code and message
                        print("SMTP error occurred: Code: {}, Message: {}".format(smtp_error.smtp_code, smtp_error.smtp_error))

        # Close the connection
        server.quit()

    except Exception as e:
        print("Failed to send email: {}".format(e))

# Function to test if SMTP port is open
def check_smtp_port():
    try:
        socket.create_connection((smtp_server, smtp_port), timeout=10)
        print("Connection to {} on port {} is successful.".format(smtp_server, smtp_port))
    except Exception as e:
        print("Failed to connect to {} on port {}: {}".format(smtp_server, smtp_port, e))

if __name__ == "__main__":
    # Check SMTP connection
    check_smtp_port()

    # Send emails with .eml files as attachments
    send_eml_files()

Key Changes:

1. dsn_options: The sendmail() function now includes the dsn_options parameter with values ['SUCCESS', 'FAILURE', 'DELAY']. This requests notifications from the recipient's server in the following cases:

SUCCESS: When the email is successfully delivered to the recipient's mailbox.

FAILURE: If the email could not be delivered (e.g., if the recipient's mailbox doesn't exist).

DELAY: If the delivery is delayed (e.g., due to temporary issues at the recipient's mail server).



2. Handling DSN Responses: The sendmail() function captures the server response, and the script prints this response to the console. The recipient's mail server (e.g., Hotmail or Gmail) may return delivery or failure reports based on these DSN requests.



Important Notes:

DSN Support: The recipient's server (Hotmail, Gmail, etc.) must support DSN. Not all mail servers support DSN, and even when supported, the recipient's mail server can decide not to send a DSN report.

Limitations: DSN does not guarantee final delivery to the inbox. It only provides information if the recipient's server chooses to respond.


SMTP Logs:

If you're using an internal SMTP server, you may also need to check your SMTP logs for additional details about the communication with external servers like Hotmail or Gmail. The logs can show bounce messages or failure reasons.


Testing:

1. Run the Script: This version of the script requests delivery status notifications from the recipient's mail server.


2. Monitor Responses: Look at the printed responses to see if there are any delivery success or failure reports returned by Hotmail, Gmail, or other external servers.



Let me know if this solution works for your setup or if you need further assistance!

