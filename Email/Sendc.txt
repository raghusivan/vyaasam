Apologies for the confusion. The dsn_options argument is not supported by the sendmail() method in Python's smtplib. Python's standard smtplib does not natively support requesting delivery status notifications (DSN) in the way I initially described. We can instead add headers to request delivery receipts and read receipts.

Here's a modified approach where:

Delivery Status Notification (DSN) and Read Receipts are requested by adding appropriate headers to the email.

This method uses Disposition-Notification-To for read receipts and Return-Receipt-To for DSN, but it depends on both the recipient's email server and the recipient's email client supporting these features.


Updated Code Without dsn_options:

import os
import smtplib
import socket
import ConfigParser
from email import message_from_file
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# Read configuration from config.ini
config = ConfigParser.ConfigParser()
config.read('config.ini')

# SMTP Configuration
smtp_server = config.get('SMTP', 'smtp_server')
smtp_port = config.getint('SMTP', 'smtp_port')
smtp_user = config.get('SMTP', 'smtp_user')
smtp_password = config.get('SMTP', 'smtp_password')

# Email Configuration
extensions = [ext.strip() for ext in config.get('Email', 'extensions').split(',')]

# Function to send .eml files as attachments, using subject from the .eml and requesting delivery/read receipts
def send_eml_files():
    try:
        # Create an SMTP connection
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.ehlo()
        server.starttls()
        server.ehlo()
        server.login(smtp_user, smtp_password)

        # Process each .eml file
        for filename in os.listdir('.'):  # Iterate through files in the current directory
            if os.path.isfile(filename) and any(filename.endswith(ext) for ext in extensions):  # Filter based on extension
                print("Processing file: {}".format(filename))
                with open(filename, 'r') as eml_file:
                    msg = message_from_file(eml_file)  # Read the .eml file as an email message

                    # Get the subject from the .eml file
                    subject = str(msg['Subject'])

                    # Create a multipart message
                    email_msg = MIMEMultipart()
                    email_msg['From'] = smtp_user
                    email_msg['To'] = config.get('Email', 'to_address')  # Assuming the recipient is set in config
                    email_msg['Subject'] = subject  # Use subject from .eml

                    # Add headers for Delivery Status Notification and Read Receipt
                    email_msg.add_header('Disposition-Notification-To', smtp_user)  # Request read receipt
                    email_msg.add_header('Return-Receipt-To', smtp_user)  # Request delivery status notification

                    # Attach a simple text body (optional)
                    body = "Please see the attached journal file."
                    email_msg.attach(MIMEText(body, 'plain'))

                    # Attach the .eml file
                    with open(filename, 'rb') as attachment_file:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(attachment_file.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', 'attachment; filename="{}"'.format(filename))
                        email_msg.attach(part)

                    # Send the email with attachment
                    response = server.sendmail(email_msg['From'], email_msg['To'], email_msg.as_string())

                    # Check the response and print it
                    if response == {}:
                        print("Email sent successfully and accepted for delivery: {}".format(filename))
                    else:
                        print("Failed to send email or not accepted for delivery: {}, response: {}".format(filename, response))

        # Close the connection
        server.quit()

    except Exception as e:
        print("Failed to send email: {}".format(e))

# Function to test if SMTP port is open
def check_smtp_port():
    try:
        socket.create_connection((smtp_server, smtp_port), timeout=10)
        print("Connection to {} on port {} is successful.".format(smtp_server, smtp_port))
    except Exception as e:
        print("Failed to connect to {} on port {}: {}".format(smtp_server, smtp_port, e))

if __name__ == "__main__":
    # Check SMTP connection
    check_smtp_port()

    # Send emails with .eml files as attachments
    send_eml_files()

Key Changes:

1. Requesting Read Receipt: The header Disposition-Notification-To requests a read receipt, asking the recipient’s email client to notify the sender when the email is read.


2. Requesting Delivery Receipt: The header Return-Receipt-To requests a delivery status notification. However, this depends on the recipient’s email server supporting this feature.



Important Notes:

Recipient Control: Both read receipts and delivery receipts are optional for recipients to provide. The recipient’s email client or server may choose not to send any notifications, even if requested.

Response Handling: As before, the script prints whether the email was successfully sent from your end and accepted for delivery.


Testing:

1. Run the Script: This will send .eml files as attachments, use their subject for the email subject, and request read and delivery receipts.


2. Check Output: The terminal output will confirm if the emails were sent and accepted for delivery.



Let me know if this resolves your issue!

