To print any delivery message or code that is returned from the SMTP server when sending an email, you can directly inspect the sendmail() response and output the serverâ€™s reply. While smtplib.sendmail() typically returns an empty dictionary {} if the email is successfully accepted for delivery, any issues or responses will be captured in the returned data.

Here's how you can modify the code to print any response from the sendmail() function:

Updated Code to Print SMTP Server Responses:

import os
import smtplib
import socket
import ConfigParser
from email import message_from_file
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# Read configuration from config.ini
config = ConfigParser.ConfigParser()
config.read('config.ini')

# SMTP Configuration
smtp_server = config.get('SMTP', 'smtp_server')
smtp_port = config.getint('SMTP', 'smtp_port')
smtp_user = config.get('SMTP', 'smtp_user')
smtp_password = config.get('SMTP', 'smtp_password')

# Email Configuration
extensions = [ext.strip() for ext in config.get('Email', 'extensions').split(',')]

# Function to send .eml files as attachments, using subject from the .eml and requesting delivery/read receipts
def send_eml_files():
    try:
        # Create an SMTP connection
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.ehlo()
        server.starttls()
        server.ehlo()
        server.login(smtp_user, smtp_password)

        # Process each .eml file
        for filename in os.listdir('.'):  # Iterate through files in the current directory
            if os.path.isfile(filename) and any(filename.endswith(ext) for ext in extensions):  # Filter based on extension
                print("Processing file: {}".format(filename))
                with open(filename, 'r') as eml_file:
                    msg = message_from_file(eml_file)  # Read the .eml file as an email message

                    # Get the subject from the .eml file
                    subject = str(msg['Subject'])

                    # Create a multipart message
                    email_msg = MIMEMultipart()
                    email_msg['From'] = smtp_user
                    email_msg['To'] = config.get('Email', 'to_address')  # Assuming the recipient is set in config
                    email_msg['Subject'] = subject  # Use subject from .eml

                    # Add headers for Delivery Status Notification and Read Receipt
                    email_msg.add_header('Disposition-Notification-To', smtp_user)  # Request read receipt
                    email_msg.add_header('Return-Receipt-To', smtp_user)  # Request delivery status notification

                    # Attach a simple text body (optional)
                    body = "Please see the attached journal file."
                    email_msg.attach(MIMEText(body, 'plain'))

                    # Attach the .eml file
                    with open(filename, 'rb') as attachment_file:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(attachment_file.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', 'attachment; filename="{}"'.format(filename))
                        email_msg.attach(part)

                    # Send the email with attachment
                    try:
                        response = server.sendmail(email_msg['From'], email_msg['To'], email_msg.as_string())

                        # Print the response from the SMTP server
                        if response == {}:
                            print("Email sent successfully and accepted for delivery: {}".format(filename))
                        else:
                            print("Email sent with a response: {}, filename: {}".format(response, filename))

                    except smtplib.SMTPResponseException as smtp_error:
                        # Catch specific SMTP errors and print the error code and message
                        print("SMTP error occurred: Code: {}, Message: {}".format(smtp_error.smtp_code, smtp_error.smtp_error))

        # Close the connection
        server.quit()

    except Exception as e:
        print("Failed to send email: {}".format(e))

# Function to test if SMTP port is open
def check_smtp_port():
    try:
        socket.create_connection((smtp_server, smtp_port), timeout=10)
        print("Connection to {} on port {} is successful.".format(smtp_server, smtp_port))
    except Exception as e:
        print("Failed to connect to {} on port {}: {}".format(smtp_server, smtp_port, e))

if __name__ == "__main__":
    # Check SMTP connection
    check_smtp_port()

    # Send emails with .eml files as attachments
    send_eml_files()

Key Changes:

1. Handling SMTP Response:

The sendmail() response is captured and printed. If the response is an empty dictionary ({}), it means the SMTP server accepted the email for delivery without any issues.

If the response contains any information, it will be printed alongside the filename.



2. SMTPResponseException Handling:

Added handling for specific SMTP response errors. If the SMTP server returns an error (such as an issue with the recipient or email content), the error code and message are printed.




Example of Possible Output:

If the email is successfully sent and accepted for delivery:

Email sent successfully and accepted for delivery: journal_001.eml

If the email is sent with some warning or non-fatal response from the SMTP server:

Email sent with a response: {<email address>: (code, 'message')}, filename: journal_001.eml

If an SMTP error occurs:

SMTP error occurred: Code: 550, Message: '5.7.1 Authentication required'


Next Steps:

1. Run the Script: This version will print any response or error code returned by the SMTP server.


2. Verify the Output: Check the terminal output for successful email deliveries or any errors returned by the SMTP server.



Let me know how this works for you!

